import mop.*;
import org.aspectjml.ajmlrac.runtime.*;
import org.aspectjml.lang.annotation.*;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.AfterReturning.*;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.annotation.Pointcut.*;
import org.aspectjml.lang.annotation.siesta.After;
import org.aspectjml.lang.annotation.siesta.After.*;
import org.aspectjml.lang.annotation.siesta.Before;
import org.aspectjml.lang.annotation.siesta.Before.*;
import java.util.HashSet;
import java.util.HashSet.*;
import java.util.Iterator;
import java.util.Iterator.*;
import java.util.Set;
import java.util.Set.*;
import java.util.Map;
import java.util.Map.Entry;


privileged aspect AspectJMLRac_mop_Iterator_HasNexHandler {

	declare precedence: AspectJMLRac$JMLRacPost4Project, AspectJMLRac_* , *;


	/** Generated by AspectJML to check the exceptional public postcondition of
	 * method vioIteratorNext. */
	after (final mop.Iterator_HasNexHandler object$rac, final java.util.Iterator i) throwing (Throwable rac$e) :
		(call(void mop.Iterator_HasNexHandler.vioIteratorNext(java.util.Iterator))) && 
		!within(*..AspectJMLRac_*) && !within(AspectJMLRac_*) && target(object$rac) && args(i) {
		JMLChecker.rethrowJMLAssertionError(rac$e, object$rac.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(object$rac))+".vioIteratorNext(java.util.Iterator)");
		boolean rac$b = true;
		String rac$ErrorMsg = "";

		if (true) {
			if (rac$e instanceof java.lang.RuntimeException) {
				java.lang.RuntimeException jml$ex = (java.lang.RuntimeException) rac$e;
				boolean rac$b1 = true;
				try{			     
					rac$b1 = true;
				}   catch (JMLNonExecutableException rac$nonExec) {
					throw new JMLEvaluationError("Invalid Expression in \"mop.Iterator_HasNexHandler.java\" by method mop.Iterator_HasNexHandler.vioIteratorNext\nCaused by: "+rac$e);
				}
				if(!rac$b1) {
					if(rac$ErrorMsg.equals("")) {
						rac$ErrorMsg = "jml$ex";
					}
					else {
						rac$ErrorMsg += " and jml$ex";
					}
				}
				rac$b = rac$b && rac$b1;
				if(rac$ErrorMsg.indexOf("and") >= 0 ){
					rac$ErrorMsg += " are ";
				}
				else{
					rac$ErrorMsg += " is ";
				}
				JMLChecker.checkExceptionalPostcondition(rac$b,"by method mop.Iterator_HasNexHandler.vioIteratorNext regarding code at \nFile \"mop.Iterator_HasNexHandler.java\""+"\n\t"+rac$ErrorMsg+rac$e, "jml$ex", true, 1, object$rac.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(object$rac))+".vioIteratorNext(java.util.Iterator)", rac$e);
			}
		}
	}


	/** Generated by AspectJML to check the exceptional public postcondition of
	 * method vioIteratorHasNext. */
	after (final mop.Iterator_HasNexHandler object$rac, final java.util.Iterator i, final boolean b) throwing (Throwable rac$e) :
		(call(void mop.Iterator_HasNexHandler.vioIteratorHasNext(java.util.Iterator, boolean))) && 
		!within(*..AspectJMLRac_*) && !within(AspectJMLRac_*) && target(object$rac) && args(i, b) {
		JMLChecker.rethrowJMLAssertionError(rac$e, object$rac.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(object$rac))+".vioIteratorHasNext(java.util.Iterator, boolean)");
		boolean rac$b = true;
		String rac$ErrorMsg = "";

		if (true) {
			if (rac$e instanceof java.lang.RuntimeException) {
				java.lang.RuntimeException jml$ex = (java.lang.RuntimeException) rac$e;
				boolean rac$b1 = true;
				try{			     
					rac$b1 = true;
				}   catch (JMLNonExecutableException rac$nonExec) {
					throw new JMLEvaluationError("Invalid Expression in \"mop.Iterator_HasNexHandler.java\" by method mop.Iterator_HasNexHandler.vioIteratorHasNext\nCaused by: "+rac$e);
				}
				if(!rac$b1) {
					if(rac$ErrorMsg.equals("")) {
						rac$ErrorMsg = "jml$ex";
					}
					else {
						rac$ErrorMsg += " and jml$ex";
					}
				}
				rac$b = rac$b && rac$b1;
				if(rac$ErrorMsg.indexOf("and") >= 0 ){
					rac$ErrorMsg += " are ";
				}
				else{
					rac$ErrorMsg += " is ";
				}
				JMLChecker.checkExceptionalPostcondition(rac$b,"by method mop.Iterator_HasNexHandler.vioIteratorHasNext regarding code at \nFile \"mop.Iterator_HasNexHandler.java\""+"\n\t"+rac$ErrorMsg+rac$e, "jml$ex", true, 1, object$rac.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(object$rac))+".vioIteratorHasNext(java.util.Iterator, boolean)", rac$e);
			}
		}
	}





	/** Generated by AspectJML to activate the SIESTA handler concer nchecking */
	@org.aspectj.lang.annotation.Aspect
	public static class AspectJMLInnerCC_mop_Iterator_HasNexHandler{
		private mop.Iterator_HasNexHandler object$siesta = new Iterator_HasNexHandler();

		//  @org.aspectj.lang.annotation.AfterReturning(pointcut = "call(mop.Iterator_HasNexHandler.new(..))", returning = "object$siesta")
		//  public void get$mop$Iterator_HasNexHandlerinstance (mop.Iterator_HasNexHandler object$siesta){//#AJML-IGNORE
		//    if(this.object$siesta == null)
		//      this.object$siesta = object$siesta;
		//  }

		/** Generated by AspectJML/Siesta to check properties for
		 * the Java members intercepted by @Before handler vioIteratorNext. */
		@org.aspectj.lang.annotation.Before("(call(* java.util.Iterator+.next()) && target(java.util.Iterator))")
		public void vioIteratorNext_Before(org.aspectj.lang.JoinPoint thisJP) {//#public void mop.Iterator_HasNexHandler.vioIteratorNext(java.util.Iterator)#'mop.Iterator_HasNexHandler' (Iterator_HasNexHandler.java:16)
			object$siesta.vioIteratorNext((java.util.Iterator)thisJP.getTarget());
		}


		@org.aspectj.lang.annotation.Pointcut(value = "(call(* java.util.Iterator+.hasNext()) && target(i))", argNames = "i")
		public void Iterator_HasNext_hasnexttrue(java.util.Iterator i) { }

		@org.aspectj.lang.annotation.AfterReturning(pointcut = "Iterator_HasNext_hasnexttrue(i)", returning = "b", argNames = "i, b")
		public void afterReturningIteratorHasNext(java.util.Iterator i, boolean b) {
			object$siesta.vioIteratorHasNext(i, b);
		}
	}
}
